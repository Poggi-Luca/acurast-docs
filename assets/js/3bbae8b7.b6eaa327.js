"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[507],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),c=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,f=d["".concat(i,".").concat(m)]||d[m]||p[m]||s;return n?r.createElement(f,o(o({ref:t},u),{},{components:n})):r.createElement(f,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=d;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<s;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8472:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>k,contentTitle:()=>v,default:()=>T,frontMatter:()=>g,metadata:()=>y,toc:()=>w});var r=n(7462),a=n(7294),s=n(3905),o=n(6010),l=n(2389),i=n(7392),c=n(7094),u=n(2466);const p="tabList__CuJ",d="tabItem_LNqP";function m(e){var t,n;const{lazy:s,block:l,defaultValue:m,values:f,groupId:b,className:h}=e,g=a.Children.map(e.children,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=f?f:g.map((e=>{let{props:{value:t,label:n,attributes:r}}=e;return{value:t,label:n,attributes:r}})),y=(0,i.l)(v,((e,t)=>e.value===t.value));if(y.length>0)throw new Error('Docusaurus error: Duplicate values "'+y.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const k=null===m?m:null!=(t=null!=m?m:null==(n=g.find((e=>e.props.default)))?void 0:n.props.value)?t:g[0].props.value;if(null!==k&&!v.some((e=>e.value===k)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+k+'" but none of its children has the corresponding value. Available values are: '+v.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:w,setTabGroupChoices:S}=(0,c.U)(),[T,x]=(0,a.useState)(k),_=[],{blockElementScrollPositionUntilNextRender:E}=(0,u.o5)();if(null!=b){const e=w[b];null!=e&&e!==T&&v.some((t=>t.value===e))&&x(e)}const O=e=>{const t=e.currentTarget,n=_.indexOf(t),r=v[n].value;r!==T&&(E(t),x(r),null!=b&&S(b,String(r)))},N=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{var r;const t=_.indexOf(e.currentTarget)+1;n=null!=(r=_[t])?r:_[0];break}case"ArrowLeft":{var a;const t=_.indexOf(e.currentTarget)-1;n=null!=(a=_[t])?a:_[_.length-1];break}}null==(t=n)||t.focus()};return a.createElement("div",{className:(0,o.Z)("tabs-container",p)},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":l},h)},v.map((e=>{let{value:t,label:n,attributes:s}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:e=>_.push(e),onKeyDown:N,onFocus:O,onClick:O},s,{className:(0,o.Z)("tabs__item",d,null==s?void 0:s.className,{"tabs__item--active":T===t})}),null!=n?n:t)}))),s?(0,a.cloneElement)(g.filter((e=>e.props.value===T))[0],{className:"margin-top--md"}):a.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==T})))))}function f(e){const t=(0,l.Z)();return a.createElement(m,(0,r.Z)({key:String(t)},e))}const b="tabItem_Ymn6";function h(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(b,r),hidden:n},t)}const g={title:"Substrate With WASM",slug:"/integrations/substrate-wasm"},v="Substrate With A WASM Smart Contract Environment",y={unversionedId:"integrations/substrate-wasm",id:"integrations/substrate-wasm",title:"Substrate With WASM",description:"Acurast can be used to fulfill directly to smart contracts deployed on Substrate chains with a pallet-contracts integration.",source:"@site/docs/integrations/substrate-wasm.mdx",sourceDirName:"integrations",slug:"/integrations/substrate-wasm",permalink:"/integrations/substrate-wasm",draft:!1,editUrl:"https://github.com/acurast/acurast-docs/docs/integrations/substrate-wasm.mdx",tags:[],version:"current",frontMatter:{title:"Substrate With WASM",slug:"/integrations/substrate-wasm"},sidebar:"docs",previous:{title:"Substrate",permalink:"/integrations/substrate"},next:{title:"Tezos",permalink:"/integrations/tezos"}},k={},w=[{value:"Example integration with a WASM smart contract",id:"example-integration-with-a-wasm-smart-contract",level:3},{value:"Job Specification",id:"job-specification",level:2},{value:"Job Registration",id:"job-registration",level:2}],S={toc:w};function T(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,r.Z)({},S,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"substrate-with-a-wasm-smart-contract-environment"},"Substrate With A WASM Smart Contract Environment"),(0,s.kt)("p",null,"Acurast can be used to fulfill directly to smart contracts deployed on Substrate chains with a ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/tree/master/frame/contracts"},"pallet-contracts")," integration."),(0,s.kt)("h3",{id:"example-integration-with-a-wasm-smart-contract"},"Example integration with a WASM smart contract"),(0,s.kt)("p",null,"The following example shows simple WASM smart contracts implemented with ",(0,s.kt)("a",{parentName:"p",href:"https://use.ink/"},"ink!"),"."),(0,s.kt)("p",null,"Keep in mind that you can do much more with Acurast and get access to all interoperability modules besides these examples."),(0,s.kt)(f,{mdxType:"Tabs"},(0,s.kt)(h,{value:"price-feed",label:"Price Feed",default:!0,mdxType:"TabItem"},'This example contract receives a result of the "Price Feed" template on the ',(0,s.kt)("a",{href:"https://console.acurast.com/create",target:"_blank"},"Acurast Console"),".",(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink;\n\n#[ink::contract]\nmod receiver {\n    #[ink(storage)]\n    pub struct Receiver {\n        price: u128,\n    }\n\n    impl Receiver {\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            Self {\n                price: Default::default(),\n            }\n        }\n\n        #[ink(message)]\n        pub fn fulfill(&mut self, price: u128) {\n            self.price = price;\n        }\n\n        #[ink(message)]\n        pub fn get_price(&self) -> u128 {\n            self.price\n        }\n    }\n}\n\n'))),(0,s.kt)(h,{value:"randomness",label:"Verifiable Randomness",mdxType:"TabItem"},'This example contract receives random bytes of the "Verifiable Randomness" template on the ',(0,s.kt)("a",{href:"https://console.acurast.com/create",target:"_blank"},"Acurast Console"),".",(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink;\n\n#[ink::contract]\nmod receiver {\n\n    #[ink(storage)]\n\n    pub struct Receiver {\n\n        price: u128,\n\n    }\n\n    /// Defines the storage of your contract.\n    /// Add new fields to the below struct in order\n    /// to add new static storage fields to your contract.\n    #[ink(storage)]\n    pub struct Receiver {\n        random_bytes: Vec<u8>,\n    }\n\n    impl Receiver {\n        #[ink(constructor)]\n        pub fn default() -> Self {\n            Self {\n                random_bytes: Default::default(),\n            }\n        }\n\n        #[ink(message)]\n        pub fn fulfill(&mut self, bytes: Vec<u8>) {\n            self.random_bytes = bytes;\n        }\n\n        #[ink(message)]\n        pub fn get_bytes(&self) -> Vec<u8> {\n            self.random_bytes.clone()\n        }\n    }\n\n}\n\n')))),(0,s.kt)("h2",{id:"job-specification"},"Job Specification"),(0,s.kt)("p",null,"Now that the contract has been deployed, we can prepare the script that will get executed by the Processor to provision the price feed or entropy."),(0,s.kt)("p",null,"Go to the ",(0,s.kt)("a",{parentName:"p",href:"https://console.acurast.com/"},"Acurast Console")," to test and deploy your script, these templates can also be found there."),(0,s.kt)(f,{mdxType:"Tabs"},(0,s.kt)(h,{value:"price-feed",label:"Price Feed",default:!0,mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'const callIndex = "0x4606"; // the call index for the \'call\' extrinsic\nconst destination = "<MY_WASM_CONTRACT_ADDRESS>"; // replace with a contract address that will receive the \'fulfill\' call.\n_STD_.chains.substrate.signer.setSigner("SECP256K1"); // the type of signer used for sign the extrinsic call, possible values are SECP256K1 or SECP256R1. What to use depends on what type of address is supported by the chain.\nconst entropy = generateSecureRandomHex();\n_STD_.chains.substrate.contract.fulfill(\n  "<SUBSTRATE_NODE_RPC_URL>",\n  callIndex,\n  destination,\n  entropy,\n  {\n    refTime: "3951114240",\n    proofSize: "629760",\n  },\n  (opHash) => {\n    print("Succeeded: " + opHash);\n  },\n  (err) => {\n    print("Failed fulfill: " + err);\n  }\n);\n'))),(0,s.kt)(h,{value:"randomness",label:"Verifiable Randomness",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'const callIndex = "0x4606"; // the call index for the \'call\' extrinsic.\nconst destination = "<MY_WASM_CONTRACT_ADDRESS>"; // contract address that will receive the \'fulfill\' call.\n_STD_.chains.substrate.signer.setSigner("SECP256K1"); // the type of signer used for sign the extrinsic call\nhttpGET(\n  "https://api.binance.com/api/v3/ticker/price?symbol=AAVEBUSD",\n  {},\n  (response, _certificate) => {\n    const price = JSON.parse(response)["price"] * 10 ** 18;\n    const payload = _STD_.chains.substrate.codec.encodeUnsignedNumber(\n      price,\n      128\n    );\n    _STD_.chains.substrate.contract.fulfill(\n      "https://rpc.shibuya.astar.network",\n      callIndex,\n      destination,\n      payload,\n      {\n        refTime: "3951114240",\n        proofSize: "629760",\n      },\n      (opHash) => {\n        print("Succeeded: " + opHash);\n      },\n      (err) => {\n        print("Failed fulfill: " + err);\n      }\n    );\n  },\n  (err) => {\n    print("Failed get price: " + err);\n  }\n);\n')))),(0,s.kt)("h2",{id:"job-registration"},"Job Registration"),(0,s.kt)("p",null,"Check out ",(0,s.kt)("a",{parentName:"p",href:"/developers/introduction#get-started"},"How to get started with the Acurast Console")," to register your Job."))}T.isMDXComponent=!0}}]);